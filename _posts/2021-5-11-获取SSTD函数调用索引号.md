---
layout:     post
title:      获取SSTD函数调用索引号
subtitle:   c++
date:       2021-5-11
author:     YiMiTuMi
header-img: 
catalog: true
tags:
    - Driver
---

#获取SSTD函数调用索引号

[参考](https://blog.csdn.net/qq_41071646/article/details/86487402?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.vipsorttest&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.vipsorttest)

Windows在调用系统API时，通过ntdll.dll文件中的函数进入内核，每个函数在进入内核时都会有一个调用编号，这个调用编号被存放在eax中，windows通过这个编号在SSTD中查找对应的函数地址。

注意：ntdll.dll 导出表的函数编号并不是SSTD的函数编号，两者并不对应。并且已经公开的函数大多数是以NT开头的，还有一些为公开的是ZW。

x64：

	mov     r10, rcx ; NtSetEventBoostPriority
	mov     eax, 2Dh ;  //其中2Dh就是调用编号

x32：

	mov     eax, 2Dh ;  //其中2Dh就是调用编号



程序：

	#include <ntddk.h>
	#include <WinDef.h>
	#include <aux_klib.h>
	
	#pragma comment(lib,"aux_klib.lib")  
	
	//查找函数
	NTSTATUS DllFileMap(UNICODE_STRING ustrDllFileName, HANDLE* phFile, HANDLE* phSection, PVOID* ppBaseAddress)
	{
		NTSTATUS status = STATUS_SUCCESS;
		HANDLE hFile = NULL;
		HANDLE hSection = NULL;
		OBJECT_ATTRIBUTES objectAttributes = { 0 };
		IO_STATUS_BLOCK iosb = { 0 };
		PVOID pBaseAddress = NULL;
		SIZE_T viewSize = 0;
	
		// 打开 DLL 文件, 并获取文件句柄
		InitializeObjectAttributes(&objectAttributes, &ustrDllFileName, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, NULL, NULL);
		status = ZwOpenFile(&hFile, GENERIC_READ, &objectAttributes, &iosb, FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT);
		if (!NT_SUCCESS(status))
		{
			KdPrint(("ZwOpenFile Error! [error code: 0x%X]", status));
			return status;
		}
	
		//创建一个节对象, 以 PE 结构中的 SectionALignment 大小对齐映射文件
		status = ZwCreateSection(&hSection, SECTION_MAP_READ | SECTION_MAP_WRITE, NULL, 0, PAGE_READWRITE, 0x1000000, hFile);
		if (!NT_SUCCESS(status))
		{
			ZwClose(hFile);
			KdPrint(("ZwCreateSection Error! [error code: 0x%X]", status));
			return status;
		}
	
		// 映射到内存
		status = ZwMapViewOfSection(hSection, NtCurrentProcess(), &pBaseAddress, 0, 1024, 0, &viewSize, ViewShare, MEM_TOP_DOWN, PAGE_READWRITE);
		if (!NT_SUCCESS(status))
		{
			ZwClose(hSection);
			ZwClose(hFile);
			KdPrint(("ZwMapViewOfSection Error! [error code: 0x%X]", status));
			return status;
		}
	
		// 返回数据
		*phFile = hFile;
		*phSection = hSection;
		*ppBaseAddress = pBaseAddress;
	
		return status;
	}
	
	//映射文件
	ULONG GetIndexFromExportTable(PVOID pBaseAddress, PCHAR pszFunctionName)
	{
		ULONG ulFunctionIndex = 0; 	// Dos Header
	
		PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBaseAddress;  // NT Header
	
		PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((PUCHAR)pDosHeader + pDosHeader->e_lfanew); // Export Table
	
		PIMAGE_EXPORT_DIRECTORY pExportTable = (PIMAGE_EXPORT_DIRECTORY)((PUCHAR)pDosHeader + pNtHeaders->OptionalHeader.DataDirectory[0].VirtualAddress);  // 有名称的导出函数个数
		ULONG ulNumberOfNames = pExportTable->NumberOfNames;
	
		// 导出函数名称地址表
		PULONG lpNameArray = (PULONG)((PUCHAR)pDosHeader + pExportTable->AddressOfNames);
		PCHAR lpName = NULL;
	
		// 开始遍历导出表
		for (ULONG i = 0; i < ulNumberOfNames; i++)
		{
			lpName = (PCHAR)((PUCHAR)pDosHeader + lpNameArray[i]);
	
			// 判断是否查找的函数，将屏蔽的去掉
			if (0 == _strnicmp(pszFunctionName, lpName, strlen(pszFunctionName)))
			{
				// 获取导出函数地址
				USHORT uHint = *(USHORT*)((PUCHAR)pDosHeader + pExportTable->AddressOfNameOrdinals + 2 * i);
				ULONG ulFuncAddr = *(PULONG)((PUCHAR)pDosHeader + pExportTable->AddressOfFunctions + 4 * uHint);
				PVOID lpFuncAddr = (PVOID)((PUCHAR)pDosHeader + ulFuncAddr);
	
				// 获取 SSDT 函数 Index，Eax 跟据系统不一样保存的语句不一样
	#ifdef _WIN64
				ulFunctionIndex = *(ULONG*)((PUCHAR)lpFuncAddr + 4);   
	#else
				ulFunctionIndex = *(ULONG*)((PUCHAR)lpFuncAddr + 1);
	#endif
	
				DbgPrint("Function = %s, , %d\n", lpName, ulFunctionIndex);
	
				break;
			}
		}
	
		return ulFunctionIndex;
	}
	
	//获取函数名对应编号
	ULONG GetSSDTFunctionIndex(UNICODE_STRING ustrDllFileName, PCHAR pszFunctionName)
	{
		ULONG ulFunctionIndex = 0;
		NTSTATUS status = STATUS_SUCCESS;
		HANDLE hFile = NULL;
		HANDLE hSection = NULL;
		PVOID pBaseAddress = NULL;
	
		// 内存映射文件
		status = DllFileMap(ustrDllFileName, &hFile, &hSection, &pBaseAddress);
		if (!NT_SUCCESS(status))
		{
			KdPrint(("DllFileMap Error!\n"));
			return ulFunctionIndex;
		}
	
		// 根据导出表获取导出函数地址, 从而获取 SSDT 函数索引号
		ulFunctionIndex = GetIndexFromExportTable(pBaseAddress, pszFunctionName);
	
		// 释放
		ZwUnmapViewOfSection(NtCurrentProcess(), pBaseAddress);
		ZwClose(hSection);
		ZwClose(hFile);
	
	}
	
	
	//卸载
	VOID DriverUpLoad(PDRIVER_OBJECT pdriver)
	{
		DbgPrint("卸载了\n");
	}
	
	
	NTSTATUS DriverEntry(PDRIVER_OBJECT pdriver, PUNICODE_STRING pReg) //返回一个地址、返回驱动被注册到注册表的某个地方
	{
		DbgPrint("pdriver = %wZ, , %x\n", pReg, pdriver);
		pdriver->DriverUnload = DriverUpLoad;
	
		
		UNICODE_STRING ustrDllFileName;
		RtlInitUnicodeString(&ustrDllFileName, L"\\??\\C:\\Windows\\System32\\ntdll.dll"); //Dll 地址
		ULONG ulSSDTFunctionIndex = GetSSDTFunctionIndex(ustrDllFileName, "ZwOpenProcess"); //查找函数名
		
	
		return STATUS_SUCCESS;
	}

## 蓝色妖姬 -- 相守

