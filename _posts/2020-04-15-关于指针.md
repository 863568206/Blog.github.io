---
layout:     post
title:      关于指针
subtitle:   C++
date:       2020-04-15
author:     YiMiTuMi
header-img: 
catalog: true
tags:
    - C++
---

## 指针的类型

	ClassTypePointer *px; //类对象指针
	
	int *pi;
	
	Array<string> *pta;

以内存需求的观点来说，它们三个没有什么不同。它们三个都需要有足够的内存来放置一个机器地址（通常是一个 word）。

“指向不同类型之各指针”间的差异，既不在起指针表示法不同，也不在其内容（代表一个地址）不同，而是在其所寻址出来的 object类型不同。

即，“**指针类型**”会导致编译器如何解释某个特定地址中的内存内容及其大小。

例：

1）一个指向地址1000的整数指针，在32位机器上，将涵盖地址空间 1000 ~ 1003。

2）如果是String是传统的 8-bytes（包括一个 4-bytes 的字符指针和一个用来表示字符长度的整数）那么一个 String 类型的指针将横跨地址空间 1000 ~ 1007。


一个指向地址 1000 而类型为 void* 的指针，将蕴含怎样的地址空间呢？ 是的，我们不知道！这就是为什么一个类型为 void* 的指针只能够含有一个地址，而不能够通过它操作所指之 object 的缘故。

转型（cast）其实是一种编译器指令。大部分情况下它并不改变一个指针所含的真正地址，他只影响“被指出之内存的大小和其内容”。的解释方式。

## 多态与指针
	
	{
		ClassTypePointer za;
		ClassTypePointer *pza;
	
		Bear b;
		Panda *pp = new Panda;
	
		pza = &b;  //会发生切割
	
	}


	ClassTypePointer
	       ↓派生
	      Bear
	       ↓派生
	     Panda


将 za 或 b 的地址，或 pp 所含的内容（也是个地址）指定给 pza，显然不是问题，一个 pointer 或一个 reference之所以支持多态，是因为它们并不引发内存中任何“与类型有关的内存操作”；会受到改变的只是它们所指向的内存的“**大小和内容解释方式**”而已。

任何人如果企图改变 object za 的大小，便会违反其定义中受契约保护的“资源需求量”。如果把整个 Bear object 指定给 za，则会溢出他所配置得到的内存，执行结果当然也就不对了。（所谓的 za = b；）

## 黄蔷薇 -- 永恒的微笑
